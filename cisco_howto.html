<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
  <head>
    <title>LINUX VLAN + Cisco HOWTO</title>
  </head>

  <body bgcolor=#ffffff text=#000000>
    <center><h1>LINUX VLAN + Cisco HOWTO</h1></center>
<P>
<pre>
0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0

  The Linux VLAN HOWTO
 
  Kristjan Kotkas <a href="mailto:kristjan@data.ee">kristjan@data.ee</a>
  Ben Greear & Others <a href="mailto:greearb@candelatech.com">greearb@candelatech.com</a>
</pre>
<P>

Contents
<ul>
  <li><a href="#targ1">1. Who, why and where</a></li>
  <li><a href="#targ2">2. Actual info on how to make it work.</a></li>
  <li><a href="#targ3">3. Specific work-arounds/patches for certain configurations.</a></li>
  <li><a href="#targ4">4. Scripts and Recipes.</a></li>
</ul>
<P>

<ol>
 <li><a name="targ1">META</a>
  <ol>
   <li>
	This is the first HOWTO for the "802.1Q VLAN implementation for Linux"<P>
	      
	Homepage: <a href="http://scry.wanfear.com/~greear/vlan.html">http://scry.wanfear.com/~greear/vlan.html</a>
	Mailing List: VLAN@Scry.WANfear.com
   </li>  
   <P>
   <li>Copyright<P>

  This document is part of the Linux HOWTO project. The copyright notice
  is the following: Unless otherwise stated, Linux HOWTO documents are
  copyrighted by their respective authors. Linux HOWTO documents may be
  reproduced and distributed in whole or in part, in any medium physical
  or electronic, as long as this copyright notice is retained on all
  copies. Commercial redistribution is allowed and encouraged; however,
  the author would like to be notified of any such distributions. All
  translations, derivative works, or aggregate works incorporating any
  Linux HOWTO documents must be covered under this copyright notice.
  That is, you may not produce a derivative work from a HOWTO and impose
  additional restrictions on its distribution. Exceptions to these rules
  may be granted under certain conditions; please contact the Linux
  HOWTO coordinator at the address given below. In short, we wish to
  promote dissemination of this information through as many channels as
  possible. However, we do wish to retain copyright on the HOWTO
  documents, and would like to be notified of any plans to redistribute
  the HOWTOs. If you have questions, please contact Tim Bynum, the Linux
  HOWTO coordinator, at linux-howto@sunsite.unc.edu via email.
   </li>
   <P>
   <li>Disclaimer<P>

  As usual: the author IS NOT responsible for any damage. For the correct
  wording, see the relevant part of the GNU GPL 0.1.1
   </li>
   <P>
   <li>Credits<P>

  Thanks to Ben Greear <a href="http://scry.wanfear.com/~greear">http://scry.wanfear.com/~greear</a>
  for the VLAN project and also to all the people who have contributed to the project.
   </li>
   <P>
   <li>General<P>

  What is VLAN is not described in this document. Info on the VLAN protocol in general
  can be found at <a href="http://www.cisco.com/warp/public/614/11.html">http://www.cisco.com/warp/public/614/11.html</a>

  Other info can also be found at 
  <a href="http://www.netlab.ohio-state.edu/~jain/refs/lsw_refs.htm">http://www.netlab.ohio-state.edu/~jain/refs/lsw_refs.htm</a>
  <a href="ftp://p8021:-go_wildcats@p8021.hep.net/8021/q-drafts/d11/q-d11.pdf">ftp://p8021:-go_wildcats@p8021.hep.net/8021/q-drafts/d11/q-d11.pdf</a>
   </li>
  </ol>
 </li>
 <P>
 <li><a name="targ2"><b>Software/Hardware (Cisco-specific setup, with some general info as well.)</b></a><P>
  <ol>
   <li>VLAN installation & Configuration on the Linux Side.<P>
<PRE>   
I have:

* Linux kernel 2.2.14
* Vlan 0.0.10 Patched into it
* Cisco Catalyst 2900XL
* 3Com 3C509B NIC using patched driver 3c59x


Currently VLAN is not part of the kernel distribution so you need to patch
it into a supported Linux kernel and re-compile.

You need the kernel source.  If you don't have it already, you can get from
ftp.kernel.org or from one of its mirrors.  If this scares you, read the
KERNEL-HOWTO.

It is assumed that you have the linux kernel source extracted, and found at:
$HOME/linux  If your setup is different, then some of these commands may
need to be slightly different.

Download the VLAN package from the vlan homepage and extract it's contents.
tar -xvzf vlan*.tar.gz

Go to the vlan directory, build the vlan tools by just typing:
make

After this you get a programm named &lt;vconfig>. This program manages all VLAN
specific configurations.

Now patch the kernel.
Go to the linux directory 
cd linux
(if you installed the kernel source from some rpm based distribution it is 
something like /usr/src/linux)
patch the kernel by typing:

patch -p 1 &lt; $HOME/vlan/vlan.patch (patch is in the vlan directory)

Time to compile your kernel. Use the make menuconfig command in your
linux directory to select your kernel options. The option related to
802.1Q VLANs is found under the Networking options.

Additional help for kernel compilation can be found in KERNEL-HOWTO

Assuming your kernel compiled cleanly, you are now ready to use it. 
Install your kernel in the normal manner (fix up your /etc/lilo.conf file 
appropriately and run lilo as root.) 
Reboot your computer and choose your new kernel. 

As your computer comes back to life, there will be little sign that you are
now 802.1Q capable.
You should see something like this:

        802.1Q VLAN Support v0.10  Ben Greear &lt;greearb@candelatech.com>
        vlan Initialization complete.


Your system is now vlan ready, lets configure some vlans:
I'm assuming that your VLAN capable network card is eth0.

First, set the eth0 state to down:

ifconfig eth0 down
</pre>

<b>Ben's Note: &nbsp;  Regarding the next section, you can run plain ethernet
and VLAN over the same NIC, but you may not want to..</b><pre>
Whatever your previous netconf was, you should move everything to vlans.
This means, that you don't set ip address to the real interface, but set it to
vlan interface. To set your eth0 with no ip:

ifconfig eth0 0.0.0.0 up

!note!
YOU MUST SET THE ETH0 TO UP, or it wont work. (ifconfig eth0 up)

Add some vlans; goto your vlan directory where you previously compiled 
vconfig and type:

vconfig add eth0 2

! Little note about VLAN 1. In Cisco systems it is the default VLAN
so you MUST start using vlans from 2.

This will create device vlan0002 to your system. Linux will think, that it
is just another network device, so you can configure it like any other. Also
you should see the interface by typing

ifconfig -a

Lets make some conf on the vlan then:
ifconfig -i vlan0002 10.0.231.1 broadcast 10.0.231.0 netmask 255.255.255.0 up

This ends the configuration at the linux side.
</pre>
</li>
<P>
<li> Specific Extreme Networks Configuration<P><pre>
  From: Craig Metz: cmetz@inner.net

Extreme configuration example:

  create vlan v42
  config vlan v42 tag 42
  config vlan v42 add port 10 tagged

  ... will create a vlan named v42, whose 802.1Q tag is 42, and connect port
10 (tag 42) to that vlan.
</pre>
</li>
<P>
<li> Cisco-specific configuration<P>
<pre>
Cisco Conf
configure the port you want to use as the trunk:

telnet switch or use the console port

ena
(will prompt for password, so have it ready)

conf t
interface FastEthernet0/24 (it doesnt have to be 0/24)
 duplex full
 speed 100
 switchport trunk encapsulation dot1q
 switchport trunk allowed vlan 2
 switchport mode trunk


This conf will do the following:

Set the port to full duplex mode; force the port to 100Mb mode; set the port
vlan encapsulation to support 802.1Q; tell the
switch that the port is allowed to run vlans through (even if you set just
VLAN 2, cisco will automatically add VLAN 1 and VLAN 1002-1005) to the port 
and set the port to trunk mode aswell. Trunk mode tells the switch that 
a number of VLANS can go through it.

Last line is usually the mother of all screw-ups. If you forget that, you
won't get your VLAN working. Simple as that.

Now configure some other port to be used as the destination for the vlan:

conf t
interface FastEthernet0/1
 duplex half
 speed 10
 switchport access vlan 2
end

Here we tell the switch to force the port 1 to half duplex 10Mb mode (normal
10 Mb NIC) and only traffic from interface VLAN 2 can go through this port.
also you can use a number of ports with VLAN 2, like a HUB ;)

You should now connect some other device to port 1.

Let it have an ip of eg. 10.0.231.2 mask 255.255.255.0

Ping linux from it

ping 10.0.231.1

If it replies scream: "YESS!!" This means, that VLAN is working.

Hard truth: It's not over, till its over.
if this works, then you are out of the woods, if not, well I hear that
tcpdump is a good tool ;-) and tcpdump that came with the vlan package even
better tool. (if you want to dump, use the one that came with vlan package)
</PRE>
<b> NOTE:  <a href="http://ethereal.zing.org">Ethereal</a> also supports VLANs,
and is much more beautiful than tcpdump, if you have GUI capabilities.</b>
<pre>

If you can ping the linux and from linux the host, you should try the
following at linux side:

ping -s 1476 10.0.231.2

If there is no reply, there is something foggy with the NIC. and you
should start debugging.  If ping -s 100 10.0.231.2 works, then it is most likely
an MTU problem with your NIC/Driver.
</PRE>
</li>
</ol>
</li>
<P>
<li><a name="targ3"><h3>Specific patches and work-arounds for various configurations.</h3></a><P>
 <ol>
  <li><B>My Tulip-based card has MTU problems.</B><P>

   Here is a patch sent in by Ben McKeegan:
      <a href="mailto:Ben.McKeegan@fitz.cam.ac.uk">Ben.McKeegan@fitz.cam.ac.uk</a> <br>
<pre>

--- drivers/net/tulip.c.orig    Thu May  4 01:16:43 2000
+++ drivers/net/tulip.c Sat Nov 25 02:39:03 2000
@@ -59,7 +59,7 @@
 
 /* Set the copy breakpoint for the copy-only-tiny-buffer Rx structure. */
 #ifdef __alpha__
-static int rx_copybreak = 1518;
+static int rx_copybreak = 1522;
 #else
 static int rx_copybreak = 100;
 #endif
@@ -89,7 +89,7 @@
 /* Operational parameters that usually are not changed. */
 /* Time in jiffies before concluding the transmitter is hung. */
 #define TX_TIMEOUT  (4*HZ)
-#define PKT_BUF_SZ             1536                    /* Size of each temporary Rx buffer.*/
+#define PKT_BUF_SZ             1540                    /* Size of each temporary Rx buffer.*/
 /* This is a mysterious value that can be written to CSR11 in the 21040 (only)
    to support a pre-NWay full-duplex signaling mechanism using short frames.
    No one knows what it should be, but if left at its default value some
@@ -457,7 +457,7 @@
 };
 
 enum desc_status_bits {
-       DescOwned=0x80000000, RxDescFatalErr=0x8000, RxWholePkt=0x0300,
+       DescOwned=0x80000000, RxDescFatalErr=0x4842, RxWholePkt=0x0300,
 };
 
 /* Ring-wrap flag in length field, use for last ring entry.
@@ -2848,8 +2848,8 @@
                                   dev->name, entry, status);
                if (--rx_work_limit &lt; 0)
                        break;
-               if ((status & 0x38008300) != 0x0300) {
-                       if ((status & 0x38000300) != 0x0300) {
+               if ((status & (0x38000000 | RxDescFatalErr | RxWholePkt)) != RxWholePkt) {
+                       if ((status & (0x38000000 | RxWholePkt)) != RxWholePkt) {
                                /* Ingore earlier buffers. */
                                if ((status & 0xffff) != 0x7fff) {
                                        if (tulip_debug > 1)
@@ -2875,10 +2875,10 @@
                        struct sk_buff *skb;
 
 #ifndef final_version
-                       if (pkt_len > 1518) {
+                       if (pkt_len > 1522) {
                                printk(KERN_WARNING "%s: Bogus packet size of %d (%#x).\n",
                                           dev->name, pkt_len, pkt_len);
-                               pkt_len = 1518;
+                               pkt_len = 1522;
                                tp->stats.rx_length_errors++;
                        }
 #endif
</pre>
</li>

  <li><B>My eepro has MTU problems.</B><P>

   Here is a patch sent in by gleb@nbase.co.il<br>
<pre>
     filename="linux-2.2.14-eepro100-vlan.patch"

--- linux/drivers/net/eepro100.c        Tue Oct 26 20:53:40 1999
+++ linux1/drivers/net/eepro100.c       Sun May 14 07:47:34 2000
@@ -377,12 +377,12 @@
 const char i82557_config_cmd[22] = {
        22, 0x08, 0, 0,  0, 0x80, 0x32, 0x03,  1, /* 1=Use MII  0=Use AUI */
        0, 0x2E, 0,  0x60, 0,
-       0xf2, 0x48,   0, 0x40, 0xf2, 0x80,              /* 0x40=Force full-duplex */
+       0xf2, 0x48,   0, 0x40, 0xfa, 0x80,              /* 0x40=Force full-duplex */
        0x3f, 0x05, };
 const char i82558_config_cmd[22] = {
        22, 0x08, 0, 1,  0, 0x80, 0x22, 0x03,  1, /* 1=Use MII  0=Use AUI */
        0, 0x2E, 0,  0x60, 0x08, 0x88,
-       0x68, 0, 0x40, 0xf2, 0xBD,              /* 0xBD->0xFD=Force full-duplex */
+       0x68, 0, 0x40, 0xfa, 0xBD,              /* 0xBD->0xFD=Force full-duplex */
        0x31, 0x05, };
 
 /* PHY media interface chips. */
</pre>
</li>
<P>
<li><B>My SysKonnect sk98lin doesn't work</b> (submitted by:  Patrick Schaaf &ltbof@bof.de>)<P>

Here's a piece needed to get SysKonnect sk98lin
driven cards to play nice; they recognize and drop incoming VLAN tagged
frames in the driver, the patch below removes that check. Tested a bit
with a Cisco Catalyst 6509 on the other side, and a fibre link, works
like a charm. The card and driver already supports MTUs up to over 9000,
so no problem on that side.
<P>
<PRE>
diff -urN linux/drivers/net/sk98lin/skge.c blues/drivers/net/sk98lin/skge.c
--- linux/drivers/net/sk98lin/skge.c    Mon Jun 19 20:42:38 2000
+++ blues/drivers/net/sk98lin/skge.c    Mon Aug  7 09:43:18 2000
@@ -1948,7 +1948,7 @@
                
                if ((Control & RX_CTRL_STAT_VALID) == RX_CTRL_STAT_VALID &&
                        (FrameStat & 
-                       (XMR_FS_ANY_ERR | XMR_FS_1L_VLAN | XMR_FS_2L_VLAN))
+                       (XMR_FS_ANY_ERR /*| XMR_FS_1L_VLAN*/ | XMR_FS_2L_VLAN))
                         == 0) {
                        SK_DBG_MSG(NULL, SK_DBGMOD_DRV,
                                SK_DBGCAT_DRV_RX_PROGRESS,("V"));

</pre>
</li>
<P>
<li><b>My 3C59X has MTU problems.</b><P>
<PRE>
Edit the 3C59x.c, find the place where it says:

static const int mtu = 1500;
and replace 1500 with
static const int mtu = 1504;
</pre>
</li>

<li><b>My 3C905B has MTU problems.</b><P>
From Matti Aarnio &lt;matti.aarnio AT sonera.fi>
<PRE>


        This is a story from the war-front of how I got
        that card to behave properly and to allow full
        ethernet sized MTUs for my VLAN channels.

        To give the salient details:

        Driver has  'static int mtu = 1500;'  line,  which
        variable isn't listed as module parameter (not that
        that obvious fix helped - somehow module parameter
        for this didn't catch at my modprobes..)

        My kludgy solution in the end was just to increase
        that statically compiled in value to   1504,  which
        however made all IP interfaces to show MTU 1504,
        which is -- bogus..

        A bit better solution (I think) is to set max received
        packet size to 1500+14+4 bytes, and not to mess with
        externally visible interface MTU size.

        Reading 3COM documentation about Wn3_MaxPktSize register
        persistance, it seems to need be re-set after every time
        the RxReset is issued.

        Further reading of 3c905C documentation seems to indicate
        that this version of the card (ASICs) will be happy to
        accept VLAN-tagged frames even without driver fixes.  Only
        3c905B (which I have) will need the change (and plain 3c905
        doesn't have MaxPktSize register at all).

        Perhaps simplest for 3c90* series cards is just define fixed
        literal telling that oversize frames are acceptable:


-       /* Set the full-duplex bit. */
-       outb(((vp->info1 & 0x8000) || vp->full_duplex ? 0x20 : 0) |
-                (dev->mtu > 1500 ? 0x40 : 0), ioaddr + Wn3_MAC_Ctrl);
+       /* Set the full-duplex bit, and allowLargePackets bit too! */
+       outb(((vp->info1 & 0x8000) || vp->full_duplex ? 0x20 : 0) |
+                0x40, ioaddr + Wn3_MAC_Ctrl);


        (and similar code at  vortex_timer(),  look for "> 1500")

        If the incoming packet is larger than can fit info buffer,
        we get an overflow error.

        An yet another alternate is to treat plain "OversizedFrame"
        indication as a non-error at packet reception:

                if ((rx_status & 0x001f4000) == 0x00104000)
                        rx_status &amp;= ~0x0010400;

        and continue with current processing at  boomerang_rx().
        At the  vortex_rx()  this code needs to be a bit different,
        likely some code re-arrangements are called for.


/Matti Aarnio &lt;matti.aarnio AT sonera.fi>
</pre>
</li>
<P>

<li><b>How to make my PCMCIA ethernet card work with VLANs?</b><P>
Per Peter Stuge:<P>

The problem was that the VLAN code in kernel header files weren't included
properly when compiling the PCMCIA stuff.  Exactly why?  I'm not sure, might
be because the PCMCIA stuff isn't the actual kernel and that means it's
missing defines that trigger the VLAN #ifdefs.
<P>
Commenting the #ifdefs in linux/netdevice.h and adding code to clear out
the struct vlan_dev_info* vlan_dev after having created the new network
device in the PCMCIA client for the networking card did the trick if I
remember correctly.  (The reason it doesn't work out-of-the-box is that the
kernel VLAN code has garbage data for the VLAN fields in struct device since
the device creator (PCMCIA client driver) doesn't know about them.)
<P>
Ben Adds:<P>
To clear out the garbage, the PCMCIA driver needs to mset the net_device structure
to zero (it should do this anyway..)  If anyone has a patch, please send it to me
and the owners of the PCMCIA code...
</pre>
</li>

</ol>
</li>
<P>
<li><a name="targ4"><h3>Scripts and Recipes.</h3></a><P>
 <ol>
  <li><B>Mandrake (RedHat-style) startup script for VLANs.</B><P>
   Contributed by: "MaxiM Basunov" &lt;maxim@idknet.com>
<PRE>
#!/bin/sh
#
# network       Bring up/down networking
#
# chkconfig: 2345 10 90
# description: Activates/Deactivates all network interfaces configured to \
#              start at boot time.
# probe: true

# Source function library.
. /etc/init.d/functions

if [ ! -f /etc/sysconfig/network ]; then
    exit 0
fi

. /etc/sysconfig/network

if [ -f /etc/sysconfig/pcmcia ]; then
 . /etc/sysconfig/pcmcia
fi


# Check that networking is up.
[ ${NETWORKING} = "no" ] && exit 0

[ -x /sbin/ifconfig ] || exit 0

# Even if IPX is configured, without the utilities we can't do much
[ ! -x /sbin/ipx_internal_net -o ! -x /sbin/ipx_configure ] && IPX=

CWD=`pwd`
cd /etc/sysconfig/network-scripts

# find all the interfaces besides loopback.
# ignore aliases, alternative configurations, and editor backup files
interfaces=`ls ifcfg* | egrep -v '(ifcfg-lo|:)' | \
            egrep -v 'ifcfg-ippp[0-9]+$' | \
>            egrep 'ifcfg-[a-z0-9\.]+$' | \
&lt;            egrep 'ifcfg-[a-z0-9]+$' | \
            sed 's/^ifcfg-//g'`

# See how we were called.
case "$1" in
  start)

   action "Setting network parameters: " sysctl -p /etc/sysctl.conf

 action "Bringing up interface lo: " ./ifup ifcfg-lo

 case "$IPX" in
   yes|true)
     /sbin/ipx_configure --auto_primary=$IPXAUTOPRIMARY \
       --auto_interface=$IPXAUTOFRAME
     if [ "$IPXINTERNALNETNUM" != "0" ]; then
        /sbin/ipx_internal_net add $IPXINTERNALNETNUM $IPXINTERNALNODENUM
     fi
     ;;
 esac
 # depreciated but we still use it.
 if [ -f /proc/sys/net/ipv4/ip_forward ] && [ "$FORWARD_IPV4" = "yes" ] ||
 "$FORWARD_IPV4" = "true" ];
     then
  action "Enabling IPv4 packet forwarding" sysctl -w net.ipv4.ip_forward=1
 fi

> action "Setting VLAN parameters: " vconfig set_name_type DEV_PLUS_VID

 for i in $interfaces; do
  if egrep -L "^ONBOOT=\"?[Nn][Oo]\"?" ifcfg-$i >/dev/null 2>&1; then
   # Probe module to preserve interface ordering
   /sbin/ifconfig $i >/dev/null 2>&1
  else
>   vlan=`echo $i | egrep -v '(lo|:)' | \
>        egrep -v 'ippp[0-9]+$' | \
>        egrep '[a-z0-9]+\.[0-9][0-9][0-9][0-9]$' | \
>        sed "s/^[a-z0-9]*\.//g;s/^0*//g"`
>   ifvlan=`echo $i | egrep -v '(lo|:)' | \
>        egrep -v 'ippp[0-9]+$' | \
>           egrep '[a-z0-9]+\.[0-9][0-9][0-9][0-9]$' | \
>        sed "s/\.[a-z0-9]*$//g"`

>   if [ -n "${vlan}" ]; then
>    action "Enable ${vlan} on {$ifvlan}: " vconfig add ${ifvlan} ${vlan}
>   fi
   action "Bringing up interface $i: " ./ifup $i boot
  fi
 done

 # Add non interface-specific static-routes.
 if [ -f /etc/sysconfig/static-routes ]; then
    grep "^any" /etc/sysconfig/static-routes | while read ignore type dest
netmask mask bogus args; do
       if [ "${bogus}" = "gw" ]; then
        /sbin/route add -$type $dest $netmask $mask $args
       else
        /sbin/route add -$type $dest $netmask $mask $bogus $args
       fi
    done
 fi

        touch /var/lock/subsys/network
        ;;
  stop)
   # If this is a final shutdown/halt, check for network FS,
 # and unmount them even if the user didn't turn on netfs

 if [ "$RUNLEVEL" = "6" -o "$RUNLEVEL" = "0" -o "$RUNLEVEL" = "1" ]; then
  NFSMTAB=`grep -v '^#' /proc/mounts | awk '{ if ($3 ~ /^nfs$/ ) print $2}'`
  SMBMTAB=`grep -v '^#' /proc/mounts | awk '{ if ($3 ~ /^smbfs$/ ) print
$2}'`
  NCPMTAB=`grep -v '^#' /proc/mounts | awk '{ if ($3 ~ /^ncpfs$/ ) print
$2}'`
  if [ -n "$NFSMTAB" -o -n "$SMBMTAB" -o -n "$NCPMTAB" ] ; then
   /etc/init.d/netfs stop
  fi
 fi

 for i in $interfaces ; do
         if ifconfig $i 2>/dev/null | grep -q "UP" >/dev/null 2>&1 ; then
     action "Shutting down interface $i: " ./ifdown $i boot
  fi
 done
 case "$IPX" in
   yes|true)
     if [ "$IPXINTERNALNETNUM" != "0" ]; then
        /sbin/ipx_internal_net del
     fi
     ;;
 esac
 ./ifdown ifcfg-lo
 if [ -d /proc/sys/net/ipv4 ]; then
   if [ -f /proc/sys/net/ipv4/ip_forward ]; then
  if [ `cat /proc/sys/net/ipv4/ip_forward` != 0 ]; then
   action "Disabling IPv4 packet forwarding: " sysctl -w
net.ipv4.ip_forward=0
  fi
   fi
   if [ -f /proc/sys/net/ipv4/ip_always_defrag ]; then
         if [ `cat /proc/sys/net/ipv4/ip_always_defrag` != 0 ]; then
          action "Disabling IPv4 automatic defragmentation: " sysctl -w
net.ipv4.ip_always_defrag=0
  fi
   fi
 fi
 if [ -f /proc/sys/net/ipv4/tcp_syncookies ];then
         if [ `cat /proc/sys/net/ipv4/tcp_syncookies` != 0 ]; then
      sysctl -w net.ipv4.tcp_syncookies=0
  fi
 fi

        rm -f /var/lock/subsys/network
        ;;
  status)
 echo "Configured devices:"
 echo lo $interfaces

 if [ -x /bin/linuxconf ] ; then
  eval `/bin/linuxconf --hint netdev`
  echo "Devices that are down:"
  echo $DEV_UP
  echo "Devices with modified configuration:"
  echo $DEV_RECONF
 else
  echo "Currently active devices:"
  echo `/sbin/ifconfig | grep ^[a-z] | awk '{print $1}'`
 fi
 ;;
  restart)
        cd $CWD
 $0 stop
 $0 start
 ;;
  reload)
 if [ -x /bin/linuxconf ] ; then
  eval `/bin/linuxconf --hint netdev`
  for device in $DEV_UP ; do
   action "Bringing up device $device: " ./ifup $device
  done
  for device in $DEV_DOWN ; do
   action "Shutting down device $device: " ./ifdown $device
  done
  for device in $DEV_RECONF ; do
   action "Shutting down device $device: " ./ifdown $device
   action "Bringing up device $device: " ./ifup $device
  done
  for device in $DEV_RECONF_ALIASES ; do
   action "Briging up alias $device: "
/etc/sysconfig/network-scripts/ifup-aliases $device
  done
  for device in $DEV_RECONF_ROUTES ; do
   action "Bringing up route $device: "
/etc/sysconfig/network-scripts/ifup-routes $device
  done
  case $IPX in yes|true)
    case $IPXINTERNALNET in
      reconf)
   action "Deleting internal IPX network: " /sbin/ipx_internal_net del
   action "Adding internal IPX network $IPXINTERNALNETNUM
$IPXINTERNALNODENUM: " /sbin/ipx_internal_net add $IPXINTERNALNETNUM \
            $IPXINTERNALNODENUM
   ;;
      add)
   action "Adding internal IPX network $IPXINTERNALNETNUM
$IPXINTERNALNODENUM: "/sbin/ipx_internal_net add $IPXINTERNALNETNUM \
            $IPXINTERNALNODENUM
   ;;
      del)
   action "Deleting internal IPX network: " /sbin/ipx_internal_net del
   ;;
    esac
    ;;
  esac
 else
         cd $CWD
  $0 restart
 fi
 ;;
  probe)
 if [ -x /bin/linuxconf ] ; then
  eval `/bin/linuxconf --hint netdev`
  [ -n "$DEV_UP$DEV_DOWN$DEV_RECONF$DEV_RECONF_ALIASES" -o \
    -n "$DEV_RECONF_ROUTES$IPXINTERNALNET" ] && \
   echo reload
  exit 0
 else
  # if linuxconf isn't around to figure stuff out for us,
  # we punt.  Probably better than completely reloading
  # networking if user isn't sure which to do.  If user
  # is sure, they would run restart or reload, not probe.
  exit 0
 fi
 ;;
  *)
        echo "Usage: network {start|stop|restart|reload|status|probe}"
        exit 1
esac

exit 0
</pre>
</li>

</ol>
<P>
<HR>
<pre>
Terv, 

-----------------------------
Kristjan Kotkas 
KPNQwest Estonia
kristjan.kotkas@kpnqwest.ee
t + 372 62 66299 m + 372 51 60697 f + 372 62 66292

</pre>


    <hr>
    <address><a href="mailto:greear@cyberhighway.net">Ben Greear</a></address>
<!-- Created: Mon May 29 12:17:35 MST 2000 -->
<!-- hhmts start -->
Last modified: Sat Jan 13 12:52:41 MST 2001
<!-- hhmts end -->
  </body>
</html>
